#!/usr/bin/env -S node --import tsx

import { existsSync } from "node:fs";
import { readFile } from "node:fs/promises";
import { homedir } from "node:os";
import { resolve } from "node:path";
import {
  asCliArgMap,
  auditExitCode,
  auditMemory,
  formatDateNowUtc,
  MemoryStatus,
  resolveMemoryLockPath,
  resolveMemoryRoot,
  withFileLock,
  writeTextFile,
} from "./memory-governance-lib";
import { buildMemoryMarkdown } from "./memory-render-format";
import { renderRuntimeTopicShards, resolveMemoryStatusPaths } from "./memory-status-lib";

const GENERATED_BLOCK_START = "<!-- OPENCLAW_MEMORY_GOVERNANCE:START -->";
const GENERATED_BLOCK_END = "<!-- OPENCLAW_MEMORY_GOVERNANCE:END -->";

function resolveWorkspaceRoot(args: Record<string, string | boolean>): string {
  const argValue = typeof args["workspace-root"] === "string" ? args["workspace-root"].trim() : "";
  if (argValue.length > 0) {
    return resolve(argValue);
  }

  const envValue = process.env.OPENCLAW_WORKSPACE_ROOT?.trim() ?? "";
  if (envValue.length > 0) {
    return resolve(envValue);
  }

  return resolve(homedir(), ".openclaw-ytb", "workspace");
}

function resolveRenderStatuses(args: Record<string, string | boolean>): MemoryStatus[] {
  const includeAll = args["all-statuses"] === true;
  const includePending = includeAll || args["include-pending"] === true;
  const includeDeprecated = includeAll || args["include-deprecated"] === true;
  const statuses: MemoryStatus[] = ["active"];
  if (includePending) {
    statuses.push("pending");
  }
  if (includeDeprecated) {
    statuses.push("deprecated");
  }
  return statuses;
}

function buildGeneratedBlock(generatedBody: string): string {
  return `${GENERATED_BLOCK_START}\n${generatedBody.trimEnd()}\n${GENERATED_BLOCK_END}\n`;
}

function mergeWithExisting(existing: string, generatedBody: string): string {
  const generatedBlock = buildGeneratedBlock(generatedBody);
  const start = existing.indexOf(GENERATED_BLOCK_START);
  const end = existing.indexOf(GENERATED_BLOCK_END);
  if (start !== -1 && end !== -1 && end >= start) {
    const before = existing.slice(0, start).trimEnd();
    const after = existing.slice(end + GENERATED_BLOCK_END.length).trimStart();
    const merged = [before, generatedBlock.trimEnd(), after].filter((part) => part.length > 0);
    return `${merged.join("\n\n")}\n`;
  }

  if (existing.trimStart().startsWith("# MEMORY (Generated)")) {
    return generatedBody;
  }

  const prefix = existing.trimEnd();
  if (prefix.length === 0) {
    return generatedBlock;
  }

  return `${prefix}\n\n## Memory Governance Snapshot\n\n${generatedBlock}`;
}

async function main() {
  const args = asCliArgMap(process.argv.slice(2));
  const today = typeof args.today === "string" ? args.today : formatDateNowUtc();
  const root = resolve(resolveMemoryRoot(args));
  const workspaceRoot = resolveWorkspaceRoot(args);
  const filePath = typeof args.file === "string" ? resolve(args.file) : resolve(root, "MEMORY.yml");
  const outputPath =
    typeof args.output === "string" ? resolve(args.output) : resolve(workspaceRoot, "MEMORY.md");

  const summary = await withFileLock(
    {
      lockPath: resolveMemoryLockPath(root, "status-store"),
    },
    async () => {
      const inspected = await auditMemory(filePath, today);
      const exitCode = auditExitCode(inspected.issues);
      if (exitCode === 2) {
        throw new Error(
          "memory:render aborted due to severe audit issues. Run memory:audit first.",
        );
      }

      const statuses = resolveRenderStatuses(args);
      const generatedBody = buildMemoryMarkdown({
        sourcePath: filePath,
        items: inspected.items,
        statuses,
        runtimeNote: "Do not edit this file directly; edit MEMORY.yml and re-run memory:render.",
      });
      const forceReplace = args["replace"] === true;
      let nextContent = generatedBody;

      if (!forceReplace && existsSync(outputPath)) {
        const existing = await readFile(outputPath, "utf8");
        nextContent = mergeWithExisting(existing, generatedBody);
      }

      await writeTextFile(outputPath, nextContent);
      const shouldRenderTopics = args["no-topics"] !== true && statuses.includes("active");
      if (shouldRenderTopics) {
        const statusPaths = resolveMemoryStatusPaths({
          ...args,
          file: filePath,
          output: outputPath,
          "workspace-root": workspaceRoot,
        });
        await renderRuntimeTopicShards(statusPaths, inspected.items);
      }

      return { inspected, exitCode, forceReplace, shouldRenderTopics };
    },
  );

  console.log("memory:render done");
  console.log(`- source: ${filePath}`);
  console.log(`- output: ${outputPath}`);
  console.log(`- mode: ${summary.forceReplace ? "replace" : "merge"}`);
  console.log(`- topic shards: ${summary.shouldRenderTopics ? "enabled" : "disabled"}`);

  process.exitCode = summary.exitCode === 1 ? 1 : 0;
}

main().catch((error: unknown) => {
  const message = error instanceof Error ? error.message : String(error);
  console.error(`memory:render failed: ${message}`);
  process.exitCode = 2;
});
